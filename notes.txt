For database column or whatever type quirks, we need a "don't do
that!" capability to warn or error when a user tries to do something
that will only bring grief.

----------------

Library namespacing:

(sdbi dbi)

(sdbi something? connector-type something? postgres[ql])

(sdbi connector ffi sqlite3)

----------------

Have a "strict" type conversion mode so that e.g. a TIMESTAMP doesn't
get automagically converted into a string?

----------------

Don't forget about star schema and OLAP.

----------------

See how widely SRFI 106 Basic socket interface has been implemented,
it's used by the (postgresql) Snow library.  Chibi Scheme' (chibi net)
hopefully does all the hard work.

----------------

Adopt Perl's influential nomencalture for the low level plumbing:

DBI database interface, what the programmer write to, does not know
query languages.  Does know in some way connection pooling.

DBD database driver, knows its particular database, is where column
types are converted to and from Scheme dynamic types.  Has at least
two layers, that and below it which is what talks to the database.

----------------

The stack:

  user code
  -
  maybe a framework
  -
  user-friendly procedures like in the PostgreSQL egg
  -
  DBI, knows interaction patterns e.g. connect, operations, transactions
  -
  DBD data mapper knows about the particular database's data types
  -
  DBD database interface knows the Scheme and interfacing to particular database
  -
  There might be a layer here to fan out to different connection methods
  -
  What John and Lassi are working on, or FFI, wire protocol, whatever
  -
  Database

----------------

Rough sketch of DBI API, prior to megering with John Cowan's Simple SQL API:

(db-connect config [anti-injection-proc]) -> db

(db-disconnect db)

(db-execute

execute needs a general optional? config argument so the programmer
can for example direct that it be prepared, or not, depending on the
default.

(db-cursor-magic

executing literal strings should be handled by a "config" arg to db-execute

how and where to pass through type conversion information for DBD top layer?

Need general, generic pass throughs from DBI to both layers of the DBD.

Include plugable connection pooling facility.

Lassi: Is there value in altering the timeout while a connection is
open? It would probably be more portable if the timeout is given once
as an option to "open-sql-database". But if it's common to keep
changing the timeout it may make sense to have this as well.

----

Errors:

John, in response to my noting the "ORA-" prefix was particularly useful.

It would be good to have a particular symbol naming each DB engine:
oracle, postgresql, mysql, sqlite, etc. And that symbol would be tossed
around in a lot of places, so library code could find out which DB it is
using.

It might be good to make the error an alist:

((engine sqlite)
  (native-error-symbol SQLITE_BUSY)
  (native-error-code-integer 5)
  (native-error-message "database is locked")
  ...any other fields...)

Obviously pick better names :)

The DB driver could return as much data as it knows with each error.
Callers can ignore the data they don't understand.

----

Type mapping regime:

Hierarchy of type mappers, the first match going down wins:

  User specified (perhaps even user supplied)
  -
  DBD database type layer supplied
  -
  standard in DBI

TBD is how these mappers interact with the lowest level

----

transactions

Example from Peter Bex, modified with a rollback procedure that does
the proper exception or continuation magic under the table:

(with-transaction db
  (lambda ()
    (query db "INSERT INTO foo (bar, qux) VALUES (1, 2)")

    (with-transaction
      (lambda ()
        (query db "INSERT INTO foo (bar, qux) VALUES (3, 4)")
        ;; Oops, decide to roll this back
        (rollback)))

    (query db "INSERT INTO foo (bar, qux) VALUES (5, 6)")))

Rolling back two or more savepoint levels is probably worse than a
80/20 case.

----

Lassi on connection parameters for opening database connections:

I'd make it (open-sql-database ...) where ... is a plist of arbitrary
key-value pairs. For example, I just implemented Postgres connect
using its C library, and it accepts tons of options like that.

[ Since then it looks like alists are better. ]

The simplicity of a single "connection string" is enticing, but the real
world is not that simple. Postgres has some legacy support to parse such
a connection string, but I haven't dared look into what kinds of
shenanigans go into it :)

For a "connection string" I'd go with a DATABASE_URL environment
variable as endorsed by 12factor. Our DB API doesn't have to worry about
that; we can give key-value pairs to the DB and the DATABASE_URL library
decomposes URLs into those pairs. I wrote such a parser for Racket:
<https://github.com/lassik/racket-database-url/blob/master/database-url.rkt>.

The database URL syntax is an unruly wild west, but other kinds of
connection strings are probably worse...

----------------

Cassandra and Neo4j both have their own query languages in the general
mold of SQL.

Cassandra from Wikipedia, CQL 3.0:

CREATE KEYSPACE MyKeySpace
  WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 3 };

USE MyKeySpace;

CREATE COLUMNFAMILY MyColumns (id text, Last text, First text, PRIMARY KEY(id));

INSERT INTO MyColumns (id, Last, First) VALUES ('1', 'Doe', 'John');

SELECT * FROM MyColumns;

Cassandra has a C/C++ library, https://github.com/datastax/cpp-driver

----------------

See also PostGIS using https://en.wikipedia.org/wiki/Simple_Features
and extensions

----------------

From: John Cowan <cowan@ccil.org>
Date: Fri, 27 Sep 2019 11:13:27 -0400
Message-ID: <CAD2gp_T25VmzdFWZoSkq9vJWFdwR8FRDmLsq8NJUmBuW=xZL_w@mail.gmail.com>
Subject: Rectangularity run wild: the MariaDB storage engine CONNECT

Since MariaDB's over the wire protocol is backward compatible with MySQL,
it is part of our first-class support set.  And Maria (but not My) has a
hidden treasure we can exploit: the CONNECT storage engine.  This is
basically an engine for talking to sources of data other than classical
base tables, such as are supported by MyISAM, Aria, InnoDB, etc.  Here are
the sources it currently supports and rectangularizes:

Fixed-length binary records
CSV and friends
dBase III/IV files (FoxBase etc.)
Flat text files
Filesystem directories (either hierarchical or non-hierarchical view)
INI files
JDBC
JSON files (if the data is reasonably rectangular)
MongoDB
ODBC (including unixODBC)
Column-oriented binary with one file per column (alpha)
XML (if the data is reasonably rectangular)
HTML tables
Zipfile directories

In some cases you have to use a CREATE TABLE to specify the
rectangularization, in other cases not.  Some are updatable directly;
others are updatable but destroy the original (updating XML gives something
matching the rectangular view, not the original more complex view), yet
others are read-only.  See
<https://mariadb.com/kb/en/library/connect-table-types-overview/> for links
to more detailed docs.

There are also engines outside CONNECT that provide similar abilities:
Cassandra, MyRocks, Object Query Graph.  See
<https://mariadb.com/kb/en/library/storage-engines/> for links.

----------------

Package: dbconfig-common
Architecture: all
Version: 2.0.9
Priority: optional
Section: admin
Origin: Ubuntu
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Original-Maintainer: Paul Gevers <elbrus@debian.org>
Bugs: https://bugs.launchpad.net/ubuntu/+filebug
Installed-Size: 1545
Depends: ucf, debconf (>= 0.5) | debconf-2.0
Suggests: dbconfig-mysql | dbconfig-pgsql | dbconfig-sqlite | dbconfig-sqlite3 | dbconfig-no-thanks
Breaks: bandwidthd-pgsql (<< 2.0.1+cvs20090917-9~)
Filename: pool/main/d/dbconfig-common/dbconfig-common_2.0.9_all.deb
Size: 600950
MD5sum: a667111a3db0147f35b9b63de8cb8b32
SHA1: db9e903b22d1d3f5904e3cf7d93ab25de3e35a21
SHA256: 97abe87d724b2ca011d745b5fb95b87b226f2ac10fd6d9d6312c938ff562e6ef
Description-en: framework that helps packages to manage databases
 This package contains the core of the dbconfig-common framework. This
 framework presents a policy and implementation for managing various databases
 used by applications included in Debian packages.
 .
 It can:
  - support MySQL/MariaDB, PostgreSQL, and SQLite based applications;
  - create or remove databases and database users;
  - access local or remote databases;
  - upgrade/modify databases when upstream changes database structure;
  - generate config files in many formats with the database info;
  - import configs from packages previously managing databases on their own;
  - prompt users with a set of normalized, pre-translated questions;
  - handle failures gracefully, with an option to retry;
  - do all the hard work automatically;
  - work for package maintainers with little effort on their part;
  - work for local admins with little effort on their part;
  - comply with an agreed upon set of standards for behavior;
  - do absolutely nothing if that is the whim of the local admin;
  - perform all operations from within the standard flow of
    package management (no additional skill is required of the local
    admin).
Description-md5: 3fa1997ed54b15c65dd46db7b40eb2f0
Supported: 5y

dbconfig-mysql - dbconfig-common MySQL/MariaDB support
dbconfig-no-thanks - dbconfig-common bypass
dbconfig-pgsql - dbconfig-common PostgreSQL support
dbconfig-sqlite3 - dbconfig-common SQLite3 support
dbconfig-sqlite - dbconfig-common SQLite support

--------

It's reported that SISC had a JDBC interface.

--------

User libraries/SRFIs that the Schemepersist stack below will support:

A Scheme version of Clojure's Korma???

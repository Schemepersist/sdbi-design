Have a "strict" type conversion mode so that e.g. a TIMESTAMP doesn't
get automagically converted into a string?

----------------

Don't forget about star schema and OLAP.

----------------

See how widely SRFI 106 Basic socket interface has been implemented,
it's used by the (postgresql) Snow library.  Chibi Scheme' (chibi net)
hopefully does all the hard work.

----------------

Adopt Perl's influential nomencalture for the low level plimbing:

DBI database interface, what the programmer write to, does not know
query languages or types.

DBD database driver, knows its particular database, is where column
types are converted to and from Scheme dynamic types.  Has two layers,
that and below it which is what talks to the database.

----------------

The stack:

  user code
  -
  maybe a framework
  -
  user-friendly procedures like in the PostgreSQL egg
  -
  DBI, knows interaction patterns e.g. connect, operations, transactions
  -
  DBD data mapper knows about the particular database's data types
  -
  DBD database interface knows the Scheme and interfacing to particular database
  -
  There might be a layer here to fan out to different connection methods
  -
  What John and Lassi are working on, or FFI, wire protocol, whatever
  -
  Database

----------------

Rough sketch of DBI API:

(sdbi-connect config [anti-injection-proc]) -> conn

(sdbi-disconnect conn)

(sdbi-query

(sdbi-cursor-magic

(sdbi-execute ... for update, delete, DDL, maybe even works for -literal?  And query??

execute needs a general optional? config argument so the programmer
can for example direct that it be prepared, or not depending on the
default.

(sdbi-execute-literal string [some magic for returning rows or the like])

how and where to pass through type conversion information for DBD top layer?

Need general, generic pass throughs from DBI to both layers of the DBD.

Include plugable connection pooling facility.

Lassi: Is there value in altering the timeout while a connection is
open? It would probably be more portable if the timeout is given once
as an option to "open-sql-database". But if it's common to keep
changing the timeout it may make sense to have this as well.

----

Errors:

John, in response to my noting the "ORA-" prefix was particularly useful.

It would be good to have a particular symbol naming each DB engine:
oracle, postgresql, mysql, sqlite, etc. And that symbol would be tossed
around in a lot of places, so library code could find out which DB it is
using.

It might be good to make the error an alist:

((engine sqlite)
  (native-error-symbol SQLITE_BUSY)
  (native-error-code-integer 5)
  (native-error-message "database is locked")
  ...any other fields...)

Obviously pick better names :)

The DB driver could return as much data as it knows with each error.
Callers can ignore the data they don't understand.

----

Type mapping regime:

Hierarchy of type mappers, the first match going down wins:

  User specified (perhaps even user supplied)
  -
  DBD database type layer supplied
  -
  standard in DBI

TBD is how these mappers interact with the lowest level

----

transactions

Example from Peter Bex, modified with a rollback procedure that does
the proper exception or continuation magic under the table:

(with-transaction db
  (lambda ()
    (query db "INSERT INTO foo (bar, qux) VALUES (1, 2)")

    (with-transaction
      (lambda ()
        (query db "INSERT INTO foo (bar, qux) VALUES (3, 4)")
        ;; Oops, decide to roll this back
        (rollback)))

    (query db "INSERT INTO foo (bar, qux) VALUES (5, 6)")))

Rolling back two or more savepoint levels is probably worse than a
80/20 case.

----

Lassi on connection parameters for opening database connections:

I'd make it
(open-sql-database ...) where ... is a plist of arbitrary key-value
pairs. For example, I just implemented Postgres connect using its C
library, and it accepts tons of options like that.

The simplicity of a single "connection string" is enticing, but the real
world is not that simple. Postgres has some legacy support to parse such
a connection string, but I haven't dared look into what kinds of
shenanigans go into it :)

For a "connection string" I'd go with a DATABASE_URL environment
variable as endorsed by 12factor. Our DB API doesn't have to worry about
that; we can give key-value pairs to the DB and the DATABASE_URL library
decomposes URLs into those pairs. I wrote such a parser for Racket:
<https://github.com/lassik/racket-database-url/blob/master/database-url.rkt>.

The database URL syntax is an unruly wild west, but other kinds of
connection strings are probably worse...

----------------

Cassandra and Neo4j both have their own query languages in the general
mold of SQL.

Cassandra from Wikipedia, CQL 3.0:

CREATE KEYSPACE MyKeySpace
  WITH REPLICATION = { 'class' : 'SimpleStrategy', 'replication_factor' : 3 };

USE MyKeySpace;

CREATE COLUMNFAMILY MyColumns (id text, Last text, First text, PRIMARY KEY(id));

INSERT INTO MyColumns (id, Last, First) VALUES ('1', 'Doe', 'John');

SELECT * FROM MyColumns;

Cassandra has a C/C++ library, https://github.com/datastax/cpp-driver

----

Neo4j

Which they say
https://neo4j.com/blog/gql-standard-query-language-property-graphs/
had a great influence in the Graph Query Language (same standards
level as SQL) in progress, first draft 20H2.  In the meanwhile:
https://neo4j.com/docs/cypher-manual/current/introduction/

MATCH (john {name: 'John'})-[:friend]->()-[:friend]->(fof)
RETURN john.name, fof.name

MATCH (user)-[:friend]->(follower)
WHERE user.name IN ['Joe', 'John', 'Sara', 'Maria', 'Steve'] AND follower.name =~ 'S.*'
RETURN user.name, follower.name

https://neo4j.com/docs/cypher-manual/current/introduction/query-the-graph/

MATCH (n {name: 'John'})-[:FRIEND]-(friend)
WITH n, count(friend) AS friendsCount
WHERE friendsCount > 3
RETURN n, friendsCount

Update:

MATCH (n {name: 'John'})-[:FRIEND]-(friend)
WITH n, count(friend) AS friendsCount
SET n.friendsCount = friendsCount
RETURN n.friendsCount

(Maybe on a following page in the introduction:)

CREATE (adam:User { name: 'Adam' }),(pernilla:User { name: 'Pernilla' }),(david:User { name: 'David'
  }),
  (adam)-[:FRIEND]->(pernilla),(pernilla)-[:FRIEND]->(david)

Neo4j.com thinks a lot of this C client + driver:
https://neo4j.com/developer/c/
https://github.com/cleishm/libneo4j-client

----------------

Existing UNIX friendly general database interface libraries for the
plumbing/physical layer:

ODBC: Legacy and thus $$

--------

Common Lisp SQL (CLSQL) appears to have its own, also LGPL, last updated 2016
http://git.kpe.io/?p=clsql.git;a=tree;f=db-odbc;h=d349c08686f215c56c1ae7f0eeb492215a3d55b9;hb=HEAD

--------

OpenDBX looks very dead.

--------

GNOME DB/libgda is hopelessly complicated and buggy, also LGPL, and typed

--------

http://libdbi.sourceforge.net/
https://sourceforge.net/projects/libdbi/
http://libdbi-drivers.sourceforge.net/
https://sourceforge.net/projects/libdbi-drivers/

libdbi no longer under development but very minimally supported, C,
LGPL, and looks typed.  Claims its design is object oriented.  Claims
it's used by Bacula, but half a decade later that's not true.

Typing that you can apply to returned results is cramped, text and
binary strings, imprecisely sized integers [BAD SMELL], floats and
doubles, and "date/time".  Would require serialization.  But looks
like you can apply dynamic typing on the fly.

From the website, would be ~2013-4:

The drivers officially supported by libdbi are:

MySQL
PostgreSQL [ A PostgreSQL building patch was done March 2019. ]
SQLite3

The following drivers are in various stages of completion and are supposed to be included into the next release(tm):

DB2
Firebird/Interbase
FreeTDS (provides access to MS SQL Server and Sybase)
Ingres
mSQL
Oracle

--------

C++: CppDB, SOCI

GPL only: libzdb, sells itself on connection pooling.

Scheme libraries:

guile dbi GPL only.

Gerbil is object oriented like or worse than Gauche: https://github.com/vyzo/gerbil/tree/master/src/std/db

sqlid.plt dead before bzlib/dbi below was developed, not part of Racket library set, LGPL.

PLT bzlib/dbi based on Perl DBI dead, LGPL, was once popular but no longer part of Racket library set, retrieved.

----------------

Package: dbconfig-common
Architecture: all
Version: 2.0.9
Priority: optional
Section: admin
Origin: Ubuntu
Maintainer: Ubuntu Developers <ubuntu-devel-discuss@lists.ubuntu.com>
Original-Maintainer: Paul Gevers <elbrus@debian.org>
Bugs: https://bugs.launchpad.net/ubuntu/+filebug
Installed-Size: 1545
Depends: ucf, debconf (>= 0.5) | debconf-2.0
Suggests: dbconfig-mysql | dbconfig-pgsql | dbconfig-sqlite | dbconfig-sqlite3 | dbconfig-no-thanks
Breaks: bandwidthd-pgsql (<< 2.0.1+cvs20090917-9~)
Filename: pool/main/d/dbconfig-common/dbconfig-common_2.0.9_all.deb
Size: 600950
MD5sum: a667111a3db0147f35b9b63de8cb8b32
SHA1: db9e903b22d1d3f5904e3cf7d93ab25de3e35a21
SHA256: 97abe87d724b2ca011d745b5fb95b87b226f2ac10fd6d9d6312c938ff562e6ef
Description-en: framework that helps packages to manage databases
 This package contains the core of the dbconfig-common framework. This
 framework presents a policy and implementation for managing various databases
 used by applications included in Debian packages.
 .
 It can:
  - support MySQL/MariaDB, PostgreSQL, and SQLite based applications;
  - create or remove databases and database users;
  - access local or remote databases;
  - upgrade/modify databases when upstream changes database structure;
  - generate config files in many formats with the database info;
  - import configs from packages previously managing databases on their own;
  - prompt users with a set of normalized, pre-translated questions;
  - handle failures gracefully, with an option to retry;
  - do all the hard work automatically;
  - work for package maintainers with little effort on their part;
  - work for local admins with little effort on their part;
  - comply with an agreed upon set of standards for behavior;
  - do absolutely nothing if that is the whim of the local admin;
  - perform all operations from within the standard flow of
    package management (no additional skill is required of the local
    admin).
Description-md5: 3fa1997ed54b15c65dd46db7b40eb2f0
Supported: 5y

dbconfig-mysql - dbconfig-common MySQL/MariaDB support
dbconfig-no-thanks - dbconfig-common bypass
dbconfig-pgsql - dbconfig-common PostgreSQL support
dbconfig-sqlite3 - dbconfig-common SQLite3 support
dbconfig-sqlite - dbconfig-common SQLite support

--------

It's reported that SISC had a JDBC interface.

--------



User libraries/SRFIs that the Schemepersist stack below will support:

John Cowan's Simple SQL

A Scheme version of Clojure's Korma?
